### 454.四数相加II，383.赎金信，15.三数之和，18.四数之和。

[day 7 第三章 哈希表](https://docs.qq.com/doc/DUElCb1NyTVpXa0Jj)

#### [454.四数相加II](https://leetcode.com/problems/4sum-ii/) 

初尝试：

```java
class Solution {
    public int fourSumCount(int[] nums1, int[] nums2, int[] nums3, int[] nums4) {
        Map<Integer, Integer> sum = new HashMap<>();
        
        for (int i = 0; i< nums1.length; i++) {
            for (int j = 0; j < nums2.length; j++) {
                int temp = nums1[i] + nums2[j];
                if (sum.containsKey(temp)) sum.put(temp, sum.get(temp) +1);
                else sum.put(temp, 1);
            }
        }
        
        int count=0;
         for (int i = 0; i< nums3.length; i++) {
            for (int j = 0; j < nums4.length; j++) {
                int temp = nums3[i] + nums4[j];
                if (sum.containsKey(0-temp)) count += sum.get(0-temp);
            }
         }
        
        
        return count;
        
    }
}
```

[代码随想录](https://programmercarl.com/0454.%E5%9B%9B%E6%95%B0%E7%9B%B8%E5%8A%A0II.html#%E5%85%B6%E4%BB%96%E8%AF%AD%E8%A8%80%E7%89%88%E6%9C%AC)

[视频讲解](https://www.bilibili.com/video/BV1Md4y1Q7Yh/?vd_source=198a0e84361b101846f9b1da10a0aea2)

> 四数之和为`0`，那么任意两个数的和与其余的两个数的和一定互为相反数。
>

优化

1. 数组的遍历

2. `HashMap` 的`getOrDefault()`函数

   ```java
   class Solution {
       public int fourSumCount(int[] A, int[] B, int[] C, int[] D) {
           int cnt = 0;
           Map<Integer, Integer> m = new HashMap<>();
           for (int a : A) {
               for (int b : B) {
                   m.put(a + b, m.getOrDefault(a + b, 0) + 1);
               }
           }
           for (int c : C) {
               for (int d : D) {
                   cnt += m.getOrDefault(-(c + d), 0);
               }
           }
           return cnt;
       }
   }
   ```

进阶：kSum II

After you solve 4Sum II, an interviewer can follow-up with 5Sum II,  6Sum II, and so on. What they are really expecting is a generalized  solution for `k` input arrays. Fortunately, the hashmap approach can be easily extended to handle more than 4 arrays.

Above, we divided four arrays into two equal groups and processed each group independently. Same way, we will divide kk arrays into two groups. For the first group, we will have \lfloor k/2 \rfloo nested loops to count sums. Another ⌈k/2⌈⌈k/2⌈ nested loops will enumerate arrays in the second group to count sums as before. Finally, we count the pairs from the two groups with sums as 0.

###### Algorithm

1. Initialize the final result count `res` as 0.

2. Divide the `k`given arrays into two groups:

   - `left`: the first `⌊k/2⌋` arrays
   - `right`: the rest `⌈k/2⌈` arrays

3. Enumerate within each group, count the sums of tuples that pick  exactly one number from each array in the group. Now, we have the sums  of all possible tuples within `left` and `right` respectively.

4. For each sum `s` in group `left`, multiple the count with the number of how many `-s` are counted in group `right`, and add the product to our final result.

   ```java
   import java.util.Map;
   
   class Solution {
       private int[][] lsts;
   
       public int fourSumCount(int[] A, int[] B, int[] C, int[] D) {
           lsts = new int[][] { A, B, C, D };
           int k = lsts.length;
           Map<Integer, Integer> left = sumCount(0, k / 2);
           Map<Integer, Integer> right = sumCount(k / 2, k);
           int res = 0;
           for (int s : left.keySet())
               res += left.get(s) * right.getOrDefault(-s, 0);
           return res;
       }
   
       private Map<Integer, Integer> sumCount(int start, int end) {
           Map<Integer, Integer> cnt = new HashMap<>();
           cnt.put(0, 1);
           for (int i = start; i < end; i++) {
               Map<Integer, Integer> map = new HashMap<>();
               for (int a : lsts[i]) {
                   for (int total : cnt.keySet()) {
                       map.put(total + a, map.getOrDefault(total + a, 0) + cnt.get(total));
                   }
               }
               cnt = map;
           }
           return cnt;
       }
   }
   ```

#### [383.赎金信 ](https://leetcode.com/problems/ransom-note/) 

初尝试：

```java
class Solution {
    public boolean canConstruct(String ransomNote, String magazine) {
        Map<Character, Integer> magazineMap = new HashMap<>();
      // The easiest way to for-each every char in a String is to use toCharArray():
        for(char i : magazine.toCharArray()) {
            magazineMap.put(i, magazineMap.getOrDefault(i, 0)+1);
        }
        
        for (char i : ransomNote.toCharArray()) {
            if (magazineMap.getOrDefault(i, 0) == 0) return false;
            magazineMap.put(i, magazineMap.get(i)-1);
        }
        return true;
        
    }
}
```

[代码随想录](https://programmercarl.com/0383.%E8%B5%8E%E9%87%91%E4%BF%A1.html#%E6%80%9D%E8%B7%AF)

> 因为题目所只有小写字母，那可以采用空间换取时间的哈希策略， 用一个长度为26的数组还记录magazine里字母出现的次数。
>
> 然后再用ransomNote去验证这个数组是否包含了ransomNote所需要的所有字母。
>
> 依然是数组在哈希法中的应用。
>
> 一些同学可能想，用数组干啥，都用map完事了，**其实在本题的情况下，使用map的空间消耗要比数组大一些的，因为map要维护红黑树或者哈希表，而且还要做哈希函数，是费时的！数据量大的话就能体现出来差别了。 所以数组更加简单直接有效！**

```java
class Solution {
    public boolean canConstruct(String ransomNote, String magazine) {
        // 定义一个哈希映射数组
        int[] record = new int[26];

        // 遍历
        for(char c : magazine.toCharArray()){
            record[c - 'a'] += 1;
        }

        for(char c : ransomNote.toCharArray()){
            record[c - 'a'] -= 1;
        }
        
        // 如果数组中存在负数，说明ransomNote字符串总存在magazine中没有的字符
        for(int i : record){
            if(i < 0){
                return false;
            }
        }

        return true;
    }
}

```

#### [15.三数之和](https://leetcode.com/problems/3sum/)

初尝试

```java
class Solution {
    public List<List<Integer>> threeSum(int[] nums) {
        List<List<Integer>> res = new ArrayList<>();
   
        Map<Integer, int[]> map = new HashMap<>();
        Set<Set<Integer>> set = new HashSet<>();
        
        for (int i = 0; i< nums.length; i++) {
            for (int j = i+1; j< nums.length; j++) {
                int sum = nums[i] + nums[j];   
                int[] temp = new int[] {i, j};
                map.put(sum, temp); // 这里选取 sum 作为key，导致 map 不能保存全部键值对
            }
        }
        
        for(int i = 0 ; i< nums.length; i++) {
            if (map.containsKey(-nums[i])) {
                int[] index = map.get(-nums[i]);
                if (index[0] != i && index[1] != i) {
                    Set<Integer> tempSet = new HashSet<>();
                    tempSet.add(index[0]);
                    tempSet.add(index[1]);
                    tempSet.add(i);
                    set.add(tempSet); // 这里 set 只能保证index 组合不重复，不能保证对应的值不重复
                }
            }
        }
        
        for (Set<Integer> i : set) {
            ArrayList<Integer> list = new ArrayList<>();
            for (int j: i) {
                list.add(nums[j]);
            }
            res.add(list);
        }
        
        return res;

    }
}
```

[代码随想录](https://programmercarl.com/0015.%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C.html) - 双指针法

[视频讲解](https://www.bilibili.com/video/BV1GW4y127qo/?spm_id_from=333.788&vd_source=198a0e84361b101846f9b1da10a0aea2)

> **其实这道题目使用哈希法并不十分合适**，因为在去重的操作中有很多细节需要注意，在面试中很难直接写出没有bug的代码。
>
> 而且使用哈希法 在使用两层for循环的时候，能做的剪枝操作很有限，虽然时间复杂度是O(n^2)，也是可以在leetcode上通过，但是程序的执行时间依然比较长 。**这道题目使用双指针法 要比哈希法高效一些。**
>
> **双指针法**一定要排序才能进行。

```java
class Solution {
    public List<List<Integer>> threeSum(int[] nums) {
        List<List<Integer>> result = new ArrayList<>();
      // 一定要排序
        Arrays.sort(nums);
			  // 找出a + b + c = 0
        // a = nums[i], b = nums[left], c = nums[right]
        for (int i = 0; i < nums.length; i++) {
            // 排序之后如果第一个元素已经大于零，那么无论如何组合都不可能凑成三元组，直接返回结果就可以了
          	if (nums[i] > 0) {
                return result;
            }
					 // 错误去重a方法，将会漏掉-1,-1,2 这种情况
            /*
            if (nums[i] == nums[i + 1]) {
                continue;
            }
            */
            // 正确去重a方法
            if (i > 0 && nums[i] == nums[i - 1]) {
                continue;
            }

            int left = i + 1;
            int right = nums.length - 1;
            while (right > left) {
                  // 去重复逻辑如果放在这里，0，0，0 的情况，可能直接导致 right<=left 了，从而漏掉了 0,0,0 这种三元组
                /*
                while (right > left && nums[right] == nums[right - 1]) right--;
                while (right > left && nums[left] == nums[left + 1]) left++;
                */
                int sum = nums[i] + nums[left] + nums[right];
                if (sum > 0) {
                    right--;
                } else if (sum < 0) {
                    left++;
                } else {
                    result.add(Arrays.asList(nums[i], nums[left], nums[right]));
									 // 去重逻辑应该放在找到一个三元组之后，对b 和 c去重
                    while (right > left && nums[right] == nums[right - 1]) right--;
                    while (right > left && nums[left] == nums[left + 1]) left++;
                    
                  	// 找到答案时，双指针同时收缩
                    right--; 
                    left++;
                }
            }
        }
        return result;
    }
}

```

也可以使用 hashSet 来去重：

```java
class Solution {
    public List<List<Integer>> threeSum(int[] nums) {
        Set<Integer> dups = new HashSet<>(); // 对a 去重
        Set<List<Integer>> res = new HashSet<>(); // 对 三元组 去重，需要结合 Collections.sort()
        Arrays.sort(nums);
        if (nums[0] > 0) return new ArrayList<>();
        for (int i = 0; i< nums.length; i++) {
            if (dups.add(nums[i])) {
                int left = i+1, right = nums.length-1;
                while (left < right) {
                    if ((nums[i] + nums[left] + nums[right]) < 0 ) left++;
                    else if ((nums[i] + nums[left] + nums[right]) > 0 ) right--;
                    else {
                        List<Integer> triplet = Arrays.asList(nums[i], nums[left], nums[right]); //使用 Array 来创建 ArrayList
                        Collections.sort(triplet);
                        res.add(triplet);
                        left++;
                        right--;
                    }
                }
            }   
        }
         return new ArrayList(res);
    }
}
```



官网题解

###### **Approach 1: Two Pointers** 

We will follow the same two pointers pattern as in [Two Sum II](https://leetcode.com/articles/two-sum-ii-input-array-is-sorted/). It requires the array to be sorted, so we'll do that first. As our BCR is O(n2)\mathcal{O}(n^2)O(n2), sorting the array would not change the overall time complexity.

To make sure the result contains unique triplets, we need to skip  duplicate values. It is easy to do because repeating values are next to  each other in a sorted array.

> If you are wondering how to solve this problem without sorting the array, go over the ["No-Sort"](https://leetcode.com/problems/3sum/solutions/593246/3sum/#approach3) approach below. There are cases when that approach is preferable, and your interviewer may probe your knowledge there.

After sorting the array, we move our pivot element `nums[i]` and analyze elements to its right. We find all pairs whose sum is equal `-nums[i]` using the two pointers pattern, so that the sum of the pivot element (`nums[i]`) and the pair (`-nums[i]`) is equal to zero.

As a quick refresher, the pointers are initially set to the first and the last element respectively. We compare the sum of these two elements to the target. If it is smaller, we increment the lower pointer `lo`. Otherwise, we decrement the higher pointer `hi`. Thus, the sum always moves toward the target, and we "prune" pairs that would move it further away. Again, this works only if the array is  sorted. Head to the [Two Sum II](https://leetcode.com/articles/two-sum-ii-input-array-is-sorted/) solution for the detailed explanation.

Algorithm

The implementation is straightforward - we just need to modify `twoSumII` to produce triplets and skip repeating values.

1. For the main function:

   - Sort the input array `nums`.
   - Iterate through the array:
     - If the current value is greater than zero, break from the loop. Remaining values cannot sum to zero.
     - If the current value is the same as the one before, skip it.
     - Otherwise, call `twoSumII` for the current position `i`.

2. For `twoSumII` function:

   - Set the low pointer `lo` to `i + 1`, and high pointer `hi` to the last index.
   - While low pointer is smaller than high:
     - If `sum` of `nums[i] + nums[lo] + nums[hi]` is less than zero, increment `lo`.
     - If `sum` is greater than zero, decrement `hi`.
     - Otherwise, we found a triplet:
       - Add it to the result `res`.
       - Decrement `hi` and increment `lo`.
       - Increment `lo` while the next value is the same as before to avoid duplicates in the result.

3. Return the result `res`.

   ```java
   class Solution {
       public List<List<Integer>> threeSum(int[] nums) {
           Arrays.sort(nums);
           List<List<Integer>> res = new ArrayList<>();
           for (int i = 0; i < nums.length && nums[i] <= 0; ++i)
               if (i == 0 || nums[i - 1] != nums[i]) {
                   twoSumII(nums, i, res);
               }
           return res;
       }
       void twoSumII(int[] nums, int i, List<List<Integer>> res) {
           int lo = i + 1, hi = nums.length - 1;
           while (lo < hi) {
               int sum = nums[i] + nums[lo] + nums[hi];
               if (sum < 0) {
                   ++lo;
               } else if (sum > 0) {
                   --hi;
               } else {
                   res.add(Arrays.asList(nums[i], nums[lo++], nums[hi--]));
                   while (lo < hi && nums[lo] == nums[lo - 1])
                       ++lo;
               }
           }
       }
   }
   ```

   

###### **Approach 2: Hashset**

Since triplets must sum up to the target value, we can try the hash table approach from the [Two Sum](https://leetcode.com/articles/two-sum/) solution. This approach won't work, however, if the sum is not necessarily equal to the target, like in [3Sum Smaller](https://leetcode.com/problems/3sum-smaller/) and [3Sum Closest](https://leetcode.com/problems/3sum-closest/).

We move our pivot element `nums[i]` and analyze elements to its right. We find all pairs whose sum is equal `-nums[i]` using the [Two Sum: One-pass Hash Table](https://leetcode.com/articles/two-sum/#approach-3-one-pass-hash-table) approach, so that the sum of the pivot element (`nums[i]`) and the pair (`-nums[i]`) is equal to zero.

To do that, we process each element `nums[j]` to the right of the pivot, and check whether a complement `-nums[i] - nums[j]` is already in the hashset. If it is, we found a triplet. Then, we add `nums[j]` to the hashset, so it can be used as a complement from that point on.

Like in the approach above, we will also sort the array so we can skip repeated values. We provide a different way to avoid duplicates in  the ["No-Sort"](https://leetcode.com/problems/3sum/solution/#approach3) approach below.

Algorithm

The main function is the same as in the [Two Pointers](https://leetcode.com/problems/3sum/solution/#approach1) approach above. Here, we use `twoSum` (instead of `twoSumII`), modified to produce triplets and skip repeating values.

1. For the main function:

   - Sort the input array `nums`.
   - Iterate through the array:
     - If the current value is greater than zero, break from the loop. Remaining values cannot sum to zero.
     - If the current value is the same as the one before, skip it.
     - Otherwise, call `twoSum` for the current position `i`.

2. For `twoSum` function:

   - For each index `j > i`in `A`:
     - Compute `complement` value as `-nums[i] - nums[j]`.
     - If `complement` exists in hashset `seen`:
       - We found a triplet - add it to the result `res`.
       - Increment `j` while the next value is the same as before to avoid duplicates in the result.
     - Add `nums[j]` to hashset `seen`

3. Return the result `res`.

   ```java
   class Solution {
       public List<List<Integer>> threeSum(int[] nums) {
           Arrays.sort(nums);
           List<List<Integer>> res = new ArrayList<>();
           for (int i = 0; i < nums.length && nums[i] <= 0; ++i)
               if (i == 0 || nums[i - 1] != nums[i]) {
                   twoSum(nums, i, res);
               }
           return res;
       }
       void twoSum(int[] nums, int i, List<List<Integer>> res) {
           var seen = new HashSet<Integer>();
           for (int j = i + 1; j < nums.length; ++j) {
               int complement = -nums[i] - nums[j];
               if (seen.contains(complement)) {
                   res.add(Arrays.asList(nums[i], nums[j], complement));
                   while (j + 1 < nums.length && nums[j] == nums[j + 1])
                       ++j;
               }
               seen.add(nums[j]);
           }
       }
   }
   ```

###### **Approach 3: "No-Sort"** 

把求两数之和与判断第三个数是否等于前两个数的相反数放在一起进行。内层`for`循环和`Set<Integer> seen = new HashSet<>();`用来储存访问过的变量并实现去重。

What if you cannot modify the input array, and you want to avoid copying it due to memory constraints?

We can adapt the hashset approach above to work for an unsorted  array. We can put a combination of three values into a hashset to avoid  duplicates. **Values in a combination should be ordered (e.g. ascending).  Otherwise, we can have results with the same values in the different  positions.**

```java
class Solution {
    public List<List<Integer>> threeSum(int[] nums) {
        Set<List<Integer>> res = new HashSet<>(); //  Set 结合 Collections.sort() 实现去重 
        
        for (int i = 0; i < nums.length; ++i) {
            Set<Integer> seen = new HashSet<>();
            for (int j = i + 1; j < nums.length; ++j) {
                int complement = -nums[i] - nums[j];
                if (seen.contains(complement)) {
                    List<Integer> triplet = Arrays.asList(nums[i], nums[j], complement);
                    Collections.sort(triplet);// 对 Array 排序才能用 set 去重
                    res.add(triplet); 
                }
                seen.add(nums[j]);
                }
            }
        return new ArrayList(res); // Set 转换为 ArrayList
    }
}
```

Time Limit Exceeded for the test case with 3,000 zeroes. 

We just need  to add few optimizations so that it works efficiently for repeated values:

1. Use another hashset `dups` to skip duplicates in the outer loop.
   - Without this optimization, the submission will time out for the test case with 3,000 zeroes. This case is handled naturally when the array  is sorted.
2. Instead of re-populating a hashset every time in the inner loop, we  can use a hashmap and populate it once. Values in the hashmap will  indicate whether we have encountered that element in the current  iteration. When we process `nums[j]`in the inner loop, we set its hashmap value to `i`. This indicates that we can now use `nums[j]` as a complement for `nums[i]`.
   - This is more like a trick to compensate for container overheads. The effect varies by language, e.g. for C++ it cuts the runtime in half.  Without this trick the submission may time out.

```java
class Solution {
    public List<List<Integer>> threeSum(int[] nums) {
        Set<List<Integer>> res = new HashSet<>();
        Set<Integer> dups = new HashSet<>(); // 去重
        Map<Integer, Integer> seen = new HashMap<>();// Instead of re-populating a hashset every time in the inner loop, we  can use a hashmap and populate it once. Values in the hashmap will  indicate whether we have encountered that element in the current  iteration.
        for (int i = 0; i < nums.length; ++i)
            if (dups.add(nums[i])) {
                for (int j = i + 1; j < nums.length; ++j) {
                    int complement = -nums[i] - nums[j];
                    if (seen.containsKey(complement) && seen.get(complement) == i) {
                        List<Integer> triplet = Arrays.asList(nums[i], nums[j], complement);
                        Collections.sort(triplet);
                        res.add(triplet);
                    }
                    seen.put(nums[j], i);
                }
            }
        return new ArrayList(res);
    }
}
```



#### [18. 四数之和](https://leetcode.com/problems/4sum/)

[代码随想录](https://programmercarl.com/0018.%E5%9B%9B%E6%95%B0%E4%B9%8B%E5%92%8C.html)
